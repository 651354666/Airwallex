"use strict";
exports.__esModule = true;
/**
 * Creates mutators for mutations.
 */
var MutatorFactory = /** @class */ (function () {
    /**
     * Initializes a new instance of the MutatorFactory class.
     *
     * @param searcher   Searches for mutator classes.
     */
    function MutatorFactory(mutatorSearcher, logger) {
        /**
         * Mutator sub-classes, keyed by dashed-case name.
         */
        this.classes = {};
        this.searcher = mutatorSearcher;
        this.logger = logger;
    }
    /**
     * Attempts to find and instantiate a mutator sub-class for a file.
     *
     * @param name   Dashed-case name of the mutator sub-class.
     * @param fileContents   Contents of the file.
     * @returns An instance of the mutator sub-class, if the sub-class can be found.
     */
    MutatorFactory.prototype.generate = function (name, fileContents) {
        if (!this.classes[name]) {
            var mutatorClass = this.searcher.search(name);
            if (!mutatorClass) {
                return undefined;
            }
            this.classes[name] = mutatorClass;
        }
        // @todo Use some form of "implements" keyword when TypeScript supports it
        return new (this.classes[name])(fileContents);
    };
    /**
     * Generates and applied a mutator, if possible.
     *
     * @param fileContents   Contents of the file.
     * @param mutation   Mutation to be applied to the file.
     * @returns The mutated file contents.
     */
    MutatorFactory.prototype.generateAndApply = function (fileContents, mutation) {
        var mutator = this.generate(mutation.type, fileContents);
        if (!mutator) {
            this.logger.onUnknownMutationType(mutation);
            return fileContents;
        }
        return mutator.mutate(fileContents, mutation, this);
    };
    return MutatorFactory;
}());
exports.MutatorFactory = MutatorFactory;
//# sourceMappingURL=mutatorFactory.js.map